---
title: Rendering State Control
---

Rendering state determines how the GPU processes geometry, including blending, depth testing, and face culling. This tutorial uses opaque and transparent objects to demonstrate how to configure rendering states. By completing this tutorial, you will learn:
- Basic concepts of rendering states
- Configuration and blending formulas of BlendState
- Depth testing and write control of DepthState
- Different processing methods for opaque and transparent objects
- Common scenarios for using different blending modes

<Image
src="https://mdn.alipayobjects.com/huamei_dmxymu/afts/img/A*cKkoT57kv5kAAAAAQYAAAAgAeuuHAQ/original"
/>


## What is Rendering State?

Rendering state is a set of settings that tells the GPU "how to render".  It mainly includes:
- **BlendState**: Controls color blending
- **DepthState**: Controls depth testing and writing
- **RasterState**: Controls rasterization
- **StencilState**: Controls stencil testing

## BlendState - Blending State

The blending state controls how newly drawn pixels are blended with existing pixels:

### Opaque Objects
```glsl
BlendState customBlendState {
Enabled = false;           // Disable blending
}
```

Opaque objects do not require blending; they directly overwrite the background color. ### Transparent Objects
```glsl
BlendState customBlendState {
Enabled = true;                    // Enable blending
SourceColorBlendFactor = BlendFactor.SourceAlpha;
DestinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
SourceAlphaBlendFactor = BlendFactor.One;
DestinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
}
```

**Blending Formula:**
```
Final Color = Source Color × SrcAlpha + Destination Color × (1 - SrcAlpha)
```

**Common Blend Factors:**
- `SrcAlpha`: Transparency of the source pixel
- `OneMinusSrcAlpha`: 1 minus the transparency of the source pixel
- `One`: 1.0
- `Zero`: 0.0

## DepthState - Depth State

The depth state controls the use of the depth buffer:

### Opaque Objects
```glsl
DepthState customDepthState {
WriteEnabled = true;        // Enable depth writing (transparent objects usually don't write to depth)
CompareFunction = CompareFunction.LessEqual;       // But still perform depth testing
}

// Specify the opaque render queue
RenderQueueType = Opaque;
```

### Transparent Objects
```glsl
DepthState customDepthState {
WriteEnabled = false;        // Disable depth writing (transparent objects usually don't write to depth)
CompareFunction = CompareFunction.LessEqual;       // But still perform depth testing
}

// Specify the transparent render queue
RenderQueueType = Transparent;
```

**Why disable depth writing for transparent objects? **
- Transparent objects may have other objects behind them.
- If depth writing is enabled, it will block the rendering of objects behind it.
- However, depth testing is still needed to determine the rendering order.

**Depth Test Functions:**
- `Less`: Passes the test if the value is less than.
- `LessEqual`: Passes the test if the value is less than or equal to.
- `Greater`: Passes the test if the value is greater than.
- `Always`: Always passes the test.
- `Never`: Never passes the test.

## Complete Shader Comparison

### Opaque Shader
```glsl
Shader "Tutorial/02-Opaque" {
SubShader "Default" {
Pass "Forward" {
// Rendering State: Standard settings for opaque objects
BlendState customBlendState {
Enabled = false;           // Disable blending
}

DepthState customDepthState {
WriteEnabled = true;       // Enable depth writing
CompareFunction = CompareFunction.LessEqual; // Depth test function
}

BlendState = customBlendState;
DepthState = customDepthState;
RenderQueueType = Opaque;

mat4 renderer_MVPMat;
vec4 material_BaseColor;

struct Attributes {
vec4 POSITION;
};

VertexShader = vert;
FragmentShader = frag;


void vert(Attributes attr) {
gl_Position = renderer_MVPMat * attr.POSITION;
}

void frag() {
gl_FragColor = material_BaseColor;
}
}
}
}
```

### Transparent Shader
```glsl
Shader "Tutorial/02-Transparent" {
SubShader "Default" {
Pass "Forward" {
// Rendering State: Standard settings for transparent objects
BlendState customBlendState {
Enabled = true;                    // Enable blending
SourceColorBlendFactor = BlendFactor.SourceAlpha;
DestinationColorBlendFactor = BlendFactor.OneMinusSourceAlpha;
SourceAlphaBlendFactor = BlendFactor.One;
DestinationAlphaBlendFactor = BlendFactor.OneMinusSourceAlpha;
}

DepthState customDepthState {
WriteEnabled = false;        // Disable depth writing (transparent objects usually don't write depth)
CompareFunction = CompareFunction.LessEqual;       // But still perform depth test
}

BlendState = customBlendState;
DepthState = customDepthState;
RenderQueueType = Transparent;

mat4 renderer_MVPMat;
vec4 material_BaseColor;
float material_Alpha;

struct Attributes {
vec4 POSITION;
};

VertexShader = vert;
FragmentShader = frag;

void vert(Attributes attr) {
gl_Position = renderer_MVPMat * attr.POSITION;
}

void frag() {
vec4 color = material_BaseColor;
color.a = material_Alpha; // Use custom alpha value
gl_FragColor = color;
}
}
}
```

## Transparency Control

Control transparency in the fragment shader:

```glsl
void frag() {
vec4 color = material_BaseColor;
color.a = material_Alpha; // Set transparency
gl_FragColor = color;
}
```


## Importance of Rendering Order

The rendering order of transparent objects is crucial:
1. **Render opaque objects first**: Write to the depth buffer
2. **Render transparent objects later**: Render from back to front, without writing to the depth buffer

```glsl
// The engine will handle the rendering order automatically, but you need to set the rendering state correctly
RenderQueueType = **;
```

## Other Blend Modes

### Additive Blending (Glow Effect)
```glsl
BlendState customBlendState {
Enabled = true;                    // Enable blending
SourceColorBlendFactor = BlendFactor.SourceAlpha;
DestinationColorBlendFactor = BlendFactor.One;
SourceAlphaBlendFactor = BlendFactor.Zero;
DestinationAlphaBlendFactor = BlendFactor.One;
}
```


## Running Results


1. Left green plane: Opaque rendering state (blending off, depth writing on)
2. Right red plane: Transparent rendering state (blending on, depth writing off)
3. Demonstrates the configuration of BlendState and DepthState
4. Transparency changes dynamically; observe the blending effect

Go to [Playground](/examples/shaderlab-02-render-state)