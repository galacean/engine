---
title: Shader
---

ShaderLab 中的 `Shader` 是传统渲染管线中着色器程序和其他引擎渲染设置相关信息的集合封装，它允许在同一个 `Shader` 对象中定义多个着色器程序，并告诉 Galacean 在渲染过程中如何选择使用它们。`Shader` 对象具有嵌套的结构，包分别对应引擎封装的 [Shader](/apis/galacean/#Shader)，[SubShader](/apis/galacean/#SubShader) 和 [ShaderPass](/apis/galacean/#ShaderPass) 对象。

```glsl
Shader "ShaderName" {
  ...
  Editor {
    ...
  }
  ...
  // 全局变量区：变量声明，结构体声明，渲染状态声明
  ...
  SubShader "SubShaderName" {
    ...
  }
  ...
}
```

## 材质属性定义

在 ShaderLab 中开发者可以通过 [`Editor`](./editor/) 指令为使用该 Shader 的自定义材质定制 Inspector 属性面板、绑定Shader UI 脚本，详细使用指南请在[相应页面](./editor)进行参考。

## 全局变量

<Callout>
ShaderLab 中全局变量包含4种类型：渲染状态(RenderState)，结构体，函数，以及单变量。
</Callout>

### 渲染状态

包含混合状态(`BlendState`)，深度状态(`DepthState`)，模板状态(`StencilState`)，光栅化状态(`RasterState`)

#### BlendState

  ```glsl
  BlendState {
    Enabled[n]: bool;
    ColorBlendOperation[n]: BlendOperation.XXX;
    AlphaBlendOperation[n]: BlendOperation.XXX;
    SourceColorBlendFactor[n]: BlendFactor.XXX;
    SourceAlphaBlendFactor[n]: BlendFactor.XXX;
    DestinationColorBlendFactor[n]: BlendFactor.XXX;
    DestinationAlphaBlendFactor[n]: BlendFactor.XXX;
    ColorWriteMask[n]: float // 0xffffffff
    BlendColor: vec4;
    AlphaToCoverage: bool;
  }
  ```
  <Callout>
  `[n]` 为 ShaderLab 预留语法，为在 [MRT](./pass/#mrt多目标渲染) 多目标渲染下对渲染目标索引的指定。当前引擎尚不支持对 MRT 下各个渲染目标的 `BlendState` 进行单独设置，因此`n` 只能是0，或者省略。
  <br/>
  [BlendOperation](/apis/galacean/#BlendOperation) 和 [BlendFactor](/apis/galacean/#BlendFactor) 枚举等同引擎 API。
  </Callout>

#### DepthState

  ```glsl
  DepthState {
    Enabled: bool;
    WriteEnabled: bool;
    CompareFunction: CompareFunction.XXX;
  }
  ```
  <Callout>
  [CompareFunction](/apis/galacean/#CompareFunction) 枚举等同引擎 API
  </Callout>

#### StencilState

  ```glsl
  StencilState {
    Enabled: bool;
    ReferenceValue: int;
    Mask: float; // 0xffffffff
    WriteMask: float; // 0xffffffff
    CompareFunctionFront: CompareFunction.XXX;
    CompareFunctionBack: CompareFunction.XXX;
    PassOperationFront: StencilOperation.XXX;
    PassOperationBack: StencilOperation.XXX;
    FailOperationFront: StencilOperation.XXX;
    FailOperationBack: StencilOperation.XXX;
    ZFailOperationFront: StencilOperation.XXX;
    ZFailOperationBack: StencilOperation.XXX;
  }
  ```
  <Callout>
  [CompareFunction](/apis/galacean/#CompareFunction) 和 [StencilOperation](/apis/galacean/#StencilOperation) 举等同引擎 API
  </Callout>

#### RasterState

  ```glsl
  RasterState {
    CullMode: CullMode.XXX;
    DepthBias: float;
    SlopeScaledDepthBias: float;
  }
  ```

  <Callout>
  [CullMode](/apis/galacean/#CullMode) 举等同引擎 API
  </Callout>

#### 在 ShaderLab 中设置 `BlendState` 示例:

```glsl showLineNumbers {7,9}
Shader "Demo" {
  ...
  BlendState customBlendState
  {
    Enabled = true;
    // 常量复制方式
    SourceColorBlendFactor = BlendFactor.SourceColor;
    // 变量赋值方式
    DestinationColorBlendFactor = material_DstBlend;
  }
  ...
  Pass "0" {
    ...
    BlendState = customBlendState;
    ...
  }
}
```

<Callout type="info">
上述案例中对于 `BlendState` 属性赋值展示了 2 种方式: **常量赋值** 和 **变量赋值** 方式:

1. **常量赋值** 指赋值语句右端为指定的对应引擎枚举变量，譬如：BlendFactor.SourceColor。

2. **变量赋值** 指赋值语句右端为任一变量名，变量具体值可由开发者通过脚本方式在运行时通过 `ShaderData.setInt("material_DstBlend", BlendFactor.SourceColor)` API 进行指定。
</Callout>

### 结构体、函数

等同 `GLSL` 中的语法，下面代码段显示了分别声明在 Shader、SubShader 和 Pass 域内的函数和结构体：

```glsl showLineNumbers {5-9, 15-19, 25-29}
Shader "PlanarShadow" {

  ...
  // 作用域为整个 Shader 模块
  mat4 getJointMatrix(sampler2D smp, float index) {
    float base = index / renderer_JointCount;
    ...
    return mat4(m0, m1, m2, m3);
  }
  ...

  SubShader "Default" {
    ...
    // 作用域为 "Default" SubShader 模块
    vec3 ShadowProjectPos(vec4 vertPos) {
      vec3 shadowPos;
      ...
      return shadowPos;
    }
    ...

    Pass "0" {
      ...
      // a2v 结构体只对 Pass "0" 可见
      struct a2v {
        vec4 POSITION;
        vec4 JOINTS_0; 
        vec4 WEIGHTS_0;
      };
      ...

    }

  }
  ...
}

```

### 变量

全局变量的声明等同 `GLSL` 中的语法。

```glsl showLineNumbers
[lowp/mediump/highp] variableType variableName;
```

### 全局变量作用域

<Callout type="info">
与其他编程语言类似，`ShaderLab` 中的全局变量也有作用域和同名覆盖原则。简单来说，全局变量的作用和可见范围仅限于其声明的模块内部，即 `Shader`、`SubShader` 和 `Pass` 模块。而同名覆盖原则指的是如果在 `Pass` 模块内存在与其上级 `SubShader` 模块内同名的全局变量，则 `Pass` 内的全局变量会覆盖 `SubShader` 内的同名全局变量。`SubShader` 和上级 `Shader` 模块同名变量的覆盖原则同理。
</Callout>
