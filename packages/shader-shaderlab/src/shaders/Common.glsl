#ifndef COMMON_INCLUDED
#define COMMON_INCLUDED

#define PI 3.14159265359
#define RECIPROCAL_PI 0.31830988618
#define EPSILON 1e-6
#define LOG2 1.442695
#define HALF_MIN 6.103515625e-5  // 2^-14, the same value for 10, 11 and 16-bit: https://www.khronos.org/opengl/wiki/Small_Float_Formats
#define HALF_EPS 4.8828125e-4    // 2^-11, machine epsilon: 1 + EPS = 1 (half of the ULP for 1.0f)

#define saturate( a ) clamp( a, 0.0, 1.0 )

float pow2(float x ) {
    return x * x;
}

vec4 RGBMToLinear(vec4 value, float maxRange ) {
    return vec4( value.rgb * value.a * maxRange, 1.0 );
}

vec4 gammaToLinear(vec4 value){
    return vec4( pow(value.rgb, vec3(2.2)), value.a);
}

vec4 linearToGamma(vec4 value){
	value = max(value, 0.0);
    return vec4( pow(value.rgb, vec3(1.0 / 2.2)), value.a);
}

// https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt
// https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt
float sRGBToLinear(float value){
    float linearRGBLo  = value / 12.92;
    float linearRGBHi  = pow((value + 0.055) / 1.055, 2.4);
    float linearRGB    = (value <= 0.04045) ? linearRGBLo : linearRGBHi;
    return linearRGB;
}

vec4 sRGBToLinear(vec4 value){
   return vec4(sRGBToLinear(value.r), sRGBToLinear(value.g), sRGBToLinear(value.b), value.a);
}

float linearToSRGB(float value){
	value = max(value, 0.0);
    return (value <= 0.0031308) ? (value * 12.9232102) : 1.055 * pow(value, 1.0 / 2.4) - 0.055;
}

vec4 linearToSRGB(vec4 value){
    return vec4(linearToSRGB(value.r), linearToSRGB(value.g), linearToSRGB(value.b), value.a);
}

// Compatible with devices that do not even support EXT_sRGB in WebGL1.0.
vec4 texture2DSRGB(sampler2D tex, vec2 uv) {
	vec4 color = texture2D(tex, uv);
	#ifdef ENGINE_NO_SRGB
		color = sRGBToLinear(color);
	#endif
	return color;
}

#ifdef HAS_TEX_LOD
	vec4 texture2DLodSRGB(sampler2D tex, vec2 uv, float lod) {
		vec4 color = texture2DLodEXT(tex, uv, lod);
		#ifdef ENGINE_NO_SRGB
			color = sRGBToLinear(color);
		#endif
		return color;
	}
#endif

vec4 outputSRGBCorrection(vec4 linearIn){
    #ifdef ENGINE_OUTPUT_SRGB_CORRECT
    	return linearToSRGB(linearIn);
    #else 
    	return linearIn;
    #endif
}


vec4 camera_DepthBufferParams;

float remapDepthBufferLinear01(float z){
	return 1.0/ (camera_DepthBufferParams.x * z + camera_DepthBufferParams.y);
}


#ifdef GRAPHICS_API_WEBGL2
	#define INVERSE_MAT(mat) inverse(mat)
#else
	mat2 inverseMat(mat2 m) {
		return mat2(m[1][1],-m[0][1],
				-m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);
	}
	mat3 inverseMat(mat3 m) {
		float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];
		float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];
		float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];

		float b01 = a22 * a11 - a12 * a21;
		float b11 = -a22 * a10 + a12 * a20;
		float b21 = a21 * a10 - a11 * a20;

		float det = a00 * b01 + a01 * b11 + a02 * b21;

		return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),
					b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),
					b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;
	}
	mat4 inverseMat(mat4 m) {
		float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],
			a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],
			a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],
			a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],

			b00 = a00 * a11 - a01 * a10,
			b01 = a00 * a12 - a02 * a10,
			b02 = a00 * a13 - a03 * a10,
			b03 = a01 * a12 - a02 * a11,
			b04 = a01 * a13 - a03 * a11,
			b05 = a02 * a13 - a03 * a12,
			b06 = a20 * a31 - a21 * a30,
			b07 = a20 * a32 - a22 * a30,
			b08 = a20 * a33 - a23 * a30,
			b09 = a21 * a32 - a22 * a31,
			b10 = a21 * a33 - a23 * a31,
			b11 = a22 * a33 - a23 * a32,

			det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

		return mat4(
			a11 * b11 - a12 * b10 + a13 * b09,
			a02 * b10 - a01 * b11 - a03 * b09,
			a31 * b05 - a32 * b04 + a33 * b03,
			a22 * b04 - a21 * b05 - a23 * b03,
			a12 * b08 - a10 * b11 - a13 * b07,
			a00 * b11 - a02 * b08 + a03 * b07,
			a32 * b02 - a30 * b05 - a33 * b01,
			a20 * b05 - a22 * b02 + a23 * b01,
			a10 * b10 - a11 * b08 + a13 * b06,
			a01 * b08 - a00 * b10 - a03 * b06,
			a30 * b04 - a31 * b02 + a33 * b00,
			a21 * b02 - a20 * b04 - a23 * b00,
			a11 * b07 - a10 * b09 - a12 * b06,
			a00 * b09 - a01 * b07 + a02 * b06,
			a31 * b01 - a30 * b03 - a32 * b00,
			a20 * b03 - a21 * b01 + a22 * b00) / det;
	}

	#define INVERSE_MAT(mat) inverseMat(mat)
#endif

vec3 safeNormalize(vec3 inVec)
{
    float dp3 = max(float(HALF_MIN), dot(inVec, inVec));
    return inVec * inversesqrt(dp3);
}

#endif